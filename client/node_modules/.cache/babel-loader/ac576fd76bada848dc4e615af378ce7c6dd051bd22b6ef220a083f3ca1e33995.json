{"ast":null,"code":"/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\nimport * as time from './time.js';\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = [];\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n  queue = [];\n};\n\n/**\n * @param {function():void} f\n */\nexport const enqueue = f => {\n  queue.push(f);\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0);\n  }\n};\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor(timeoutId) {\n    this._ = timeoutId;\n  }\n  destroy() {\n    clearFunction(this._);\n  }\n};\nconst Timeout = createTimeoutClass(clearTimeout);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout));\nconst Interval = createTimeoutClass(clearInterval);\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const interval = (timeout, callback) => new Interval(setInterval(callback, timeout));\n\n/* c8 ignore next */\nexport const Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));\n\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next */\nexport const animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));\n\n/* c8 ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));\n\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @param {number} triggerAfter Optional. Trigger callback after a certain amount of time\n *                              without waiting for debounce.\n */\nexport const createDebouncer = (timeout, triggerAfter = -1) => {\n  let timer = -1;\n  /**\n   * @type {number?}\n    */\n  let lastCall = null;\n  /**\n   * @param {((...args: any)=>void)?} cb function to trigger after debounce. If null, it will reset the\n   *                         debounce.\n   */\n  return cb => {\n    clearTimeout(timer);\n    if (cb) {\n      if (triggerAfter >= 0) {\n        const now = time.getUnixTime();\n        if (lastCall === null) lastCall = now;\n        if (now - lastCall > triggerAfter) {\n          lastCall = null;\n          timer = /** @type {any} */setTimeout(cb, 0);\n          return;\n        }\n      }\n      timer = /** @type {any} */setTimeout(() => {\n        lastCall = null;\n        cb();\n      }, timeout);\n    } else {\n      lastCall = null;\n    }\n  };\n};","map":{"version":3,"names":["time","queue","_runQueue","i","length","enqueue","f","push","setTimeout","createTimeoutClass","clearFunction","TT","constructor","timeoutId","_","destroy","Timeout","clearTimeout","timeout","callback","Interval","clearInterval","interval","setInterval","Animation","arg","requestAnimationFrame","cancelAnimationFrame","animationFrame","cb","Idle","cancelIdleCallback","idleCallback","requestIdleCallback","createDebouncer","triggerAfter","timer","lastCall","now","getUnixTime"],"sources":["/Users/dheerajkumar/Desktop/Collaborative_Editor/client/node_modules/lib0/eventloop.js"],"sourcesContent":["/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\nimport * as time from './time.js'\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nexport const enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* c8 ignore next */\nexport const Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg))\n\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next */\nexport const animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* c8 ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg))\n\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @param {number} triggerAfter Optional. Trigger callback after a certain amount of time\n *                              without waiting for debounce.\n */\nexport const createDebouncer = (timeout, triggerAfter = -1) => {\n  let timer = -1\n  /**\n   * @type {number?}\n    */\n  let lastCall = null\n  /**\n   * @param {((...args: any)=>void)?} cb function to trigger after debounce. If null, it will reset the\n   *                         debounce.\n   */\n  return cb => {\n    clearTimeout(timer)\n    if (cb) {\n      if (triggerAfter >= 0) {\n        const now = time.getUnixTime()\n        if (lastCall === null) lastCall = now\n        if (now - lastCall > triggerAfter) {\n          lastCall = null\n          timer = /** @type {any} */ (setTimeout(cb, 0))\n          return\n        }\n      }\n      timer = /** @type {any} */ (setTimeout(() => { lastCall = null; cb() }, timeout))\n    } else {\n      lastCall = null\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}