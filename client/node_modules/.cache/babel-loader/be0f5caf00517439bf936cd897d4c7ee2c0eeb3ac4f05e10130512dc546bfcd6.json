{"ast":null,"code":"/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js';\nimport * as math from './math.js';\nimport * as number from './number.js';\nimport * as string from './string.js';\nimport * as error from './error.js';\nimport * as encoding from './encoding.js';\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array');\nconst errorIntegerOutOfRange = error.create('Integer out of Range');\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor(uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array;\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0;\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array);\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length;\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr);\n  _decoder.pos = newPos;\n  return _decoder;\n};\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n  decoder.pos += len;\n  return view;\n};\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder));\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos);\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++;\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++];\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n  decoder.pos += 2;\n  return uint;\n};\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;\n  decoder.pos += 4;\n  return uint;\n};\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos];\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder => decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0;\n  let mult = 1;\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult; // shift $r << (7*#iterations) and add it to num\n    mult *= 128; // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num;\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray;\n};\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++];\n  let num = r & binary.BITS6;\n  let mult = 64;\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1;\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num;\n  }\n  const len = decoder.arr.length;\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++];\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult;\n    mult *= 128;\n    if (r < binary.BIT8) {\n      return sign * num;\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange;\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray;\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos;\n  const s = readVarUint(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos;\n  const s = readVarInt(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder);\n  if (remainingLen === 0) {\n    return '';\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)); // remember to decrease remainingLen\n    if (--remainingLen < 100) {\n      // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder));\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000;\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n        decoder.pos += nextLen;\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */bytes);\n        remainingLen -= nextLen;\n      }\n    }\n    return decodeURIComponent(escape(encodedString));\n  }\n};\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder => /** @type any */string.utf8TextDecoder.decode(readVarUint8Array(decoder));\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder();\n  let b;\n  while (true) {\n    b = readUint8(decoder);\n    if (b === 0) {\n      return encoding.toUint8Array(encoder);\n    }\n    if (b === 1) {\n      b = readUint8(decoder);\n    }\n    encoding.write(encoder, b);\n  }\n};\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder));\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos;\n  const s = readVarString(decoder);\n  decoder.pos = pos;\n  return s;\n};\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n  decoder.pos += len;\n  return dv;\n};\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */readFromDataView(decoder, 8).getBigInt64(0, false);\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */readFromDataView(decoder, 8).getBigUint64(0, false);\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [decoder => undefined,\n// CASE 127: undefined\ndecoder => null,\n// CASE 126: null\nreadVarInt,\n// CASE 125: integer\nreadFloat32,\n// CASE 124: float32\nreadFloat64,\n// CASE 123: float64\nreadBigInt64,\n// CASE 122: bigint\ndecoder => false,\n// CASE 121: boolean (false)\ndecoder => true,\n// CASE 120: boolean (true)\nreadVarString,\n// CASE 119: string\ndecoder => {\n  // CASE 118: object<string,any>\n  const len = readVarUint(decoder);\n  /**\n   * @type {Object<string,any>}\n   */\n  const obj = {};\n  for (let i = 0; i < len; i++) {\n    const key = readVarString(decoder);\n    obj[key] = readAny(decoder);\n  }\n  return obj;\n}, decoder => {\n  // CASE 117: array<any>\n  const len = readVarUint(decoder);\n  const arr = [];\n  for (let i = 0; i < len; i++) {\n    arr.push(readAny(decoder));\n  }\n  return arr;\n}, readVarUint8Array // CASE 116: Uint8Array\n];\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder);\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor(uint8Array, reader) {\n    super(uint8Array);\n    /**\n     * The reader\n     */\n    this.reader = reader;\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = this.reader(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {T} */this.s;\n  }\n}\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor(uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n  }\n\n  /**\n   * @return {number}\n   */\n  read() {\n    this.s += readVarInt(this);\n    return this.s;\n  }\n}\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor(uint8Array, start) {\n    super(uint8Array);\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start;\n    this.count = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read() {\n    if (this.count === 0) {\n      this.s += readVarInt(this);\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1; // read the current value forever\n      }\n    }\n    this.count--;\n    return /** @type {number} */this.s;\n  }\n}\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */this.s;\n  }\n}\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n  }\n  read() {\n    if (this.count === 0) {\n      this.s = readVarInt(this);\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s);\n      this.count = 1;\n      if (isNegative) {\n        this.s = -this.s;\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.count--;\n    return /** @type {number} */this.s++;\n  }\n}\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    super(uint8Array);\n    /**\n     * @type {number}\n     */\n    this.s = 0;\n    this.count = 0;\n    this.diff = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  read() {\n    if (this.count === 0) {\n      const diff = readVarInt(this);\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1;\n      this.diff = math.floor(diff / 2); // shift >> 1\n      this.count = 1;\n      if (hasCount) {\n        this.count = readVarUint(this) + 2;\n      }\n    }\n    this.s += this.diff;\n    this.count--;\n    return this.s;\n  }\n}\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor(uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array);\n    this.str = readVarString(this.decoder);\n    /**\n     * @type {number}\n     */\n    this.spos = 0;\n  }\n\n  /**\n   * @return {string}\n   */\n  read() {\n    const end = this.spos + this.decoder.read();\n    const res = this.str.slice(this.spos, end);\n    this.spos = end;\n    return res;\n  }\n}","map":{"version":3,"names":["binary","math","number","string","error","encoding","errorUnexpectedEndOfArray","create","errorIntegerOutOfRange","Decoder","constructor","uint8Array","arr","pos","createDecoder","hasContent","decoder","length","clone","newPos","_decoder","readUint8Array","len","view","Uint8Array","buffer","byteOffset","readVarUint8Array","readVarUint","readTailAsUint8Array","skip8","readUint8","readUint16","uint","readUint32","readUint32BigEndian","peekUint8","peekUint16","peekUint32","num","mult","r","BITS7","BIT8","MAX_SAFE_INTEGER","readVarInt","BITS6","sign","BIT7","peekVarUint","s","peekVarInt","_readVarStringPolyfill","remainingLen","encodedString","String","fromCodePoint","nextLen","bytes","subarray","apply","decodeURIComponent","escape","_readVarStringNative","utf8TextDecoder","decode","readVarString","readTerminatedUint8Array","encoder","createEncoder","b","toUint8Array","write","readTerminatedString","decodeUtf8","peekVarString","readFromDataView","dv","DataView","readFloat32","getFloat32","readFloat64","getFloat64","readBigInt64","getBigInt64","readBigUint64","getBigUint64","readAnyLookupTable","undefined","obj","i","key","readAny","push","RleDecoder","reader","count","read","IntDiffDecoder","start","RleIntDiffDecoder","UintOptRleDecoder","isNegative","isNegativeZero","IncUintOptRleDecoder","IntDiffOptRleDecoder","diff","hasCount","floor","StringDecoder","str","spos","end","res","slice"],"sources":["/Users/dheerajkumar/Desktop/Collaborative_Editor/client/node_modules/lib0/decoding.js"],"sourcesContent":["/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}