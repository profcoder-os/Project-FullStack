{"ast":null,"code":"/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\nimport * as time from './time.js';\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nexport const create = f => (/** @type {Promise<T>} */new Promise(f));\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nexport const createEmpty = f => new Promise(f);\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template {unknown[] | []} PS\n *\n * @param {PS} ps\n * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}\n */\nexport const all = Promise.all.bind(Promise);\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nexport const reject = reason => Promise.reject(reason);\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nexport const resolve = res => Promise.resolve(res);\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nexport const resolveWith = res => Promise.resolve(res);\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n * @deprecated use untilAsync instead\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nexport const until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = time.getUnixTime();\n  const hasTimeout = timeout > 0;\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle);\n      resolve();\n    } else if (hasTimeout) {\n      /* c8 ignore else */\n      if (time.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle);\n        reject(new Error('Timeout'));\n      }\n    }\n  };\n  const intervalHandle = setInterval(untilInterval, intervalResolution);\n});\n\n/**\n * @param {()=>Promise<boolean>|boolean} check\n * @param {number} timeout\n * @param {number} intervalResolution\n * @return {Promise<void>}\n */\nexport const untilAsync = async (check, timeout = 0, intervalResolution = 10) => {\n  const startTime = time.getUnixTime();\n  const noTimeout = timeout <= 0;\n  // eslint-disable-next-line no-unmodified-loop-condition\n  while (noTimeout || time.getUnixTime() - startTime <= timeout) {\n    if (await check()) return;\n    await wait(intervalResolution);\n  }\n  throw new Error('Timeout');\n};\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nexport const wait = timeout => create((resolve, _reject) => setTimeout(resolve, timeout));\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nexport const isPromise = p => p instanceof Promise || p && p.then && p.catch && p.finally;","map":{"version":3,"names":["time","create","f","Promise","createEmpty","all","bind","reject","reason","resolve","res","resolveWith","until","timeout","check","intervalResolution","startTime","getUnixTime","hasTimeout","untilInterval","clearInterval","intervalHandle","Error","setInterval","untilAsync","noTimeout","wait","_reject","setTimeout","isPromise","p","then","catch","finally"],"sources":["/Users/dheerajkumar/Desktop/Collaborative_Editor/client/node_modules/lib0/promise.js"],"sourcesContent":["/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\nimport * as time from './time.js'\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nexport const create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nexport const createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template {unknown[] | []} PS\n *\n * @param {PS} ps\n * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}\n */\nexport const all = Promise.all.bind(Promise)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nexport const reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nexport const resolve = res => Promise.resolve(res)\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nexport const resolveWith = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n * @deprecated use untilAsync instead\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nexport const until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = time.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* c8 ignore else */\n      if (time.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error('Timeout'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {()=>Promise<boolean>|boolean} check\n * @param {number} timeout\n * @param {number} intervalResolution\n * @return {Promise<void>}\n */\nexport const untilAsync = async (check, timeout = 0, intervalResolution = 10) => {\n  const startTime = time.getUnixTime()\n  const noTimeout = timeout <= 0\n  // eslint-disable-next-line no-unmodified-loop-condition\n  while (noTimeout || time.getUnixTime() - startTime <= timeout) {\n    if (await check()) return\n    await wait(intervalResolution)\n  }\n  throw new Error('Timeout')\n}\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nexport const wait = timeout => create((resolve, _reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nexport const isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}